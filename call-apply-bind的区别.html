<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        let obj={
            name:'张三',
            age:18,
            sayHello:function(job,slarry){
                console.log(`姓名：${this.name},年龄：${this.age},工作是：${job},薪资:${slarry}`)
            }
        }
        obj.sayHello('打工仔',1000)
        let obj1={
            name:'李四',
            age:20,
        }
        // obj.sayHello.call(obj1,'打工',2000)
        // 上面的代码中，我们obj1对象也想使用obj对象中的sayHello方法；我们就可以使用call方法调用obj.sayHello,
        //  并将obj.sayHello中的this修改为obj1，把 '打工',2000 这两个参数出给obj.sayHello。

        // obj.sayHello.apply(obj1,['打工',2000])
        // fn.apply的作用和call相同：修改this指向，并立即执行fn。区别在于传参形式不同，apply接受两个参数，
        // 第一个参数是要指向的this对象，第二个参数是一个数组，数组里面的元素会被展开传入fn,作为fn的参数。

        obj.sayHello.bind(obj1,'打工',2000)()
        // fn.bind的作用是只修改this指向，但不会立即执行fn；会返回一个修改了this指向后的fn。
        // 需要调用才会执行:bind(thisArg, arg1, arg2, arg3, ...)()。bind的传参和call相同。
        
        // 1、相同点
        // 三个都是用于改变this指向；
        // 接收的第一个参数都是this要指向的对象；
        // 都可以利用后续参数传参。
        // 2、不同点
        // call和bind传参相同，多个参数依次传入的；
        // apply只有两个参数，第二个参数为数组；
        // call和apply都是对函数进行直接调用，而bind方法不会立即调用函数，而是返回一个修改this后的函数。
    </script>
</body>
</html>